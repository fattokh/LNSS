close all;
clear all;
clc;

file = "input.csv";
input = readmatrix(file);
settings = initSettings();
addpath include            
addpath geoFunctions 
input(:,1) = [];

satpos = zeros(3,size(input,2));
obs = zeros(1, size(input,2));
receiver_position = [0;0;0];


for k = 1:size(input,2)
satpos(:,k) = input(7:9,k);
obs(:,k) = input(6,k);
end

c_0 = 299792458;

[pos, el, az,dop] = leastSquarePosition(satpos, obs, settings);

p = input(6,:);
pdot = input(10,:);
satVel = input(11:13, :).';
satpos = satpos.';

%{
validateattributes(p, {'double', 'single'}, {'vector', 'real', 'finite'});

N = numel(p);
validateattributes(satpos, {'double', 'single'}, ...
    {'2d', 'nrows', N, 'ncols', 3, 'real', 'finite'});

validateattributes(pdot, {'double', 'single'}, ...
    {'vector', 'numel', N, 'real', 'finite'});

validateattributes(satVel, {'double', 'single'}, ...
    {'2d', 'nrows', N, 'ncols', 3, 'real', 'finite'});
%}
refFrame = fusion.internal.frames.NED;

initPosECEF = [0 0 0];
initVelECEF = [0 0 0];
[posECEF, gnssVelECEF, dopMatrix] = computeLocation(p, pdot, satpos, satVel, initPosECEF, initVelECEF);

lla = ecef2lla(posECEF);
xo =zeros(8,1);
prs = p;
gpsEph = pdot;

%[xHat,z,svPos,H,Wpr,Wrr] = WeightedLeastSquares(p,pdot,xo);
jWk=1; jSec=2; jSv=3; jPr=4; jPrSig=5; jPrr=6; jPrrSig=7;%index of columns


xHat=[]; z=[]; H=[]; svPos=[];
xyz0 = xo(1:3);
bc = xo(4);
%error = "error";
numVal=4;
if numVal<4
  error("error");
end
ttxWeek = prs(:,jWk); %week of tx. Note - we could get a rollover, when ttx_sv
%goes negative, and it is handled in GpsEph2Pvt, where we work with fct
ttxSeconds =  prs(:,jSec) - prs(:,jPr)/GpsConstants.LIGHTSPEED; %ttx by sv clock 
% this is accurate satellite time of tx, because we use actual pseudo-ranges 
% here, not corrected ranges
% write the equation for pseudorange to see the rx clock error exactly cancel
% to get precise GPS time: we subtract the satellite clock error from sv time, 
% as done next:
dtsv = GpsEph2Dtsv(gpsEph,ttxSeconds);
dtsv = dtsv(:); %make into a column for compatibility with other time vectors
ttx = ttxSeconds - dtsv; %subtract dtsv from sv time to get true gps time

%calculate satellite position at ttx
[svXyzTtx,dtsv,svXyzDot,dtsvDot]=GpsEph2Pvt(gpsEph,[ttxWeek,ttx]);
svXyzTrx = svXyzTtx; %initialize svXyz at time of reception

%Compute weights ---------------------------------------------------
Wpr = diag(1./prs(:,jPrSig));
Wrr = diag(1./prs(:,jPrrSig));

%iterate on this next part tilL change in pos & line of sight vectors converge
xHat=zeros(4,1);
dx=xHat+inf;
whileCount=0; maxWhileCount=100; 
%we expect the while loop to converge in < 10 iterations, even with initial
%position on other side of the Earth (see Stanford course AA272C "Intro to GPS")
while norm(dx) > GnssThresholds.MAXDELPOSFORNAVM
    whileCount=whileCount+1;
    assert(whileCount < maxWhileCount,...
        'while loop did not converge after %d iterations',whileCount);
    for i=1:length(gpsEph)
        % calculate tflight from, bc and dtsv
        dtflight = (prs(i,jPr)-bc)/GpsConstants.LIGHTSPEED + dtsv(i);
        % Use of bc: bc>0 <=> pr too big <=> tflight too big.
        %   i.e. trx = trxu - bc/GpsConstants.LIGHTSPEED
        % Use of dtsv: dtsv>0 <=> pr too small <=> tflight too small.
        %   i.e ttx = ttxsv - dtsv
        svXyzTrx(i,:) = FlightTimeCorrection(svXyzTtx(i,:), dtflight);
    end

  %calculate line of sight vectors and ranges from satellite to xo
  v = xyz0(:)*ones(1,numVal,1) - svXyzTrx';%v(:,i) = vector from sv(i) to xyz0
  range = sqrt( sum(v.^2) );
  v = v./(ones(3,1)*range); % line of sight unit vectors from sv to xo

  svPos=[prs(:,3),svXyzTrx,dtsv(:)];

  %calculate the a-priori range residual
  prHat = range(:) + bc -GpsConstants.LIGHTSPEED*dtsv;
  % Use of bc: bc>0 <=> pr too big <=> rangehat too big
  % Use of dtsv: dtsv>0 <=> pr too small
    
  zPr = prs(:,jPr)-prHat; 
  H = [v', ones(numVal,1)]; % H matrix = [unit vector,1]
  
  %z = Hx, premultiply by W: Wz = WHx, and solve for x:
  dx = pinv(Wpr*H)*Wpr*zPr;

  % update xo, xhat and bc
  xHat=xHat+dx;
  xyz0=xyz0(:)+dx(1:3);
  bc=bc+dx(4);

  %Now calculate the a-posteriori range residual
  zPr = zPr-H*dx;
end

% Compute velocities ---------------------------------------------------------
rrMps = zeros(numVal,1);
for i=1:numVal
    %range rate = [satellite velocity] dot product [los from xo to sv]
    rrMps(i) = -svXyzDot(i,:)*v(:,i);
end
prrHat = rrMps + xo(8) - GpsConstants.LIGHTSPEED*dtsvDot;
zPrr = prs(:,jPrr)-prrHat;
%z = Hx, premultiply by W: Wz = WHx, and solve for x:
vHat = pinv(Wrr*H)*Wrr*zPrr;
xHat = [xHat;vHat]; 

z = [zPr;zPrr];


